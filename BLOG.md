This post is about a bug that was recently found in Linux kernel [CVE-2021-31440](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8835) and how it can be discovered and fixed using formal verification.

The affected function is `reg_combine_64_into_32`. 
The function uses the known bounds on a 64-bit register (`smin_value`, `smax_value`) to infer bounds
for the register’s lower 32 bits (`s32_min_value`, `s32_max_value`). 

First, the bounds are set to minimal and maximal signed and unsigned values respectively (`S32Min, S32Max` etc).

Then in (1), after checking whether min and max values are withing 32-bit bounds, 
the register's allowed min and max values are updated accordingly.

The mistake is in the lines (2) and (3), where the checks are performed separately, which leads to a case
when the minimal value is updated, but the maximal is not and the bounds are inferred incorrectly. 
For instance, assume that `reg->umin_value = 1` and `reg->umax_value = 1 << 32`. 
Then the minimal 32-bit bound will be set to 1 after then check in (2).
(3) is false, so the maximal value will not be updated. The inferred bounds are incorrect, since the lower 32 bits of `umax_value` are 0.

Check out a detailed description of the bug
and how it is exploited see 
[here](https://www.zerodayinitiative.com/blog/2021/5/26/cve-2021-31440-an-incorrect-bounds-calculation-in-the-linux-kernel-ebpf-verifier).

```C 
static void __reg_combine_64_into_32(struct bpf_reg_state *reg) 
{ 
    __mark_reg32_unbounded(reg); 
 
    if (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) { (1) 
        reg->s32_min_value = (s32)reg->smin_value; 
        reg->s32_max_value = (s32)reg->smax_value; 
    } 
    if (__reg64_bound_u32(reg->umin_value))    // (2) 
        reg->u32_min_value = (u32)reg->umin_value; 
    if (__reg64_bound_u32(reg->umax_value))    // (3)
        reg->u32_max_value = (u32)reg->umax_value; 
 
    __reg_deduce_bounds(reg); 
    __reg_bound_offset(reg); 
    __update_reg_bounds(reg); 
}
```

The proposed fix is to replace (2) and (3) with 

```C 
if (__reg64_bound_u32(reg->umin_value) && (__reg64_bound_u32(reg->umax_value)){ 

        reg->u32_min_value = (u32)reg->umin_value; 
        reg->u32_max_value = (u32)reg->umax_value; 
        }
```

so that `u32_min_value` and `u32_max_value` updated together. Then in the previous example the bounds won't be updated 
and `u32_max_value` will stay `U32MIN`.

We can show in Coq that the replacement actually fixes the problem. It is fixed, if the following statements 
(a) and (b) are true after executing the function: "Either both min and max values are updated, or neither".


``` 
(a) (s32_min_value = (int64_to_32 smin_value64)  /\ s32_max_value = (int64_to_32 smax_value64)) 
              \/ 
    (s32_min_value = S32Min /\ s32_max_value = S32Max);     
          
(b) (u32_min_value = (int64_to_32 umin_value64) /\ u32_max_value' = (int64_to_32 umax_value64)) 
              \/ 
    (u32_min_value = U32Min /\ u32_max_value = U32Max
```

We prove that `__reg_combine_64_into_32` corresponds to this specification in Coq using [Verifiable Software Toolchain](https://vst.cs.princeton.edu/). 

That is, we prove a separation logic triple `PRE{C}POST`, 
where in precondition we state that input to the function is any reg struct with the following fields,
`f__reg_combine_64_into_32` is an abstract representation of the C program produced by [CompCert](https://compcert.org/) and the postcondition
states that values stored in reg after execution are correct.


```
PRE := (s32_min_value, s32_max_value, u32_min_value, u32_max_value,
             smin_value64, smax_value64, umin_value64, umax_value64) <- reg)             
C:= f__reg_combine_64_into_32
POST :=  (s32_min_value, s32_max_value, u32_min_value, u32_max_value,
             smin_value64, smax_value64, umin_value64, umax_value64) <- reg); 
      (s32_min_value = (int64_to_32 smin_value64)  /\ s32_max_value = (int64_to_32 smax_value64)) 
              \/ 
      (s32_min_value = S32Min /\ s32_max_value = S32Max);     
      (u32_min_value = (int64_to_32 umin_value64) /\ u32_max_value' = (int64_to_32 umax_value64)) 
              \/ 
      (u32_min_value = U32Min /\ u32_max_value = U32Max

```


We write specifications for auxiliary functions ` __mark_reg32_unbounded` and `__reg64_bound_u32` and assume that other functions do nothing.

The proof is done using separation logic and by so-called forward simulation: 
we start with the precondition (which is empty in our case) and prove that the postcondition is true once we reach the last statement of the program.
We can see that in the buggy version, the proof doesn't go through and we are left with statements that cannot be proven. 
These correspond to possible bugs in the program. 

Hence, formal verification can both help find bugs and exploits, as well prove that there is none.

For the full specification and proof go [here]().